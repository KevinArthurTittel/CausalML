library(grf)
library(sandwich)
library(lmtest)
library(Hmisc)
library(ggplot2)
library(standardize)
library(foreign)
library(stats)
library(haven)
library(ggplot2)
library(glmnet)
set.seed(123)

# Import and prepare Microfinance data set (Field et al., 2013)
  Grace_Period_Data <- read_dta("Downloads/112672-V1/Grace-Period-Data.dta")
  Grace_Period_Data <- as.data.frame(Grace_Period_Data)

  # Appoint treatment assignment and outcome variables
    W <- Grace_Period_Data$sec_treat
    W <- as.vector(W)

  # Create a numerical vector of the character group name vector
    loangroups <- as.numeric(factor(Grace_Period_Data$sec_group_name))

  # Standardize the continuous variables
    Grace_Period_Data$Years_Education_C <- scale(Grace_Period_Data$Years_Education_C)
    Grace_Period_Data$Age_C <- scale(Grace_Period_Data$Age_C)
    Grace_Period_Data$SEI <- scale(Grace_Period_Data$SEI)
    Grace_Period_Data$HH_Size_C <- scale(Grace_Period_Data$HH_Size_C)

  # Appoint the control variables matrix
    X <- Grace_Period_Data[,c(2,6,8:18)]
    colnames(X) <- c("Loan.Officer", "Stratification", "Age", "Married", "Literate", "Muslim", "HH.Size", "Years.Education", "Shock", "Has.Business",
                 "Financial.Control", "Home.Owner", "No.Drain")
                 
  # Create loan group dummies (as in original analysis) to be added to control variables matrix
    loansize1 <- as.integer(c(Grace_Period_Data$sec_loanamount == 4000))
    loansize2 <- as.integer(c(Grace_Period_Data$sec_loanamount == 5000))
    loansize3 <- as.integer(c(Grace_Period_Data$sec_loanamount == 6000))
    loansize4 <- as.integer(c(Grace_Period_Data$sec_loanamount == 8000))
    loansize5 <- as.integer(c(Grace_Period_Data$sec_loanamount == 9000))
    loansize6 <- as.integer(c(Grace_Period_Data$sec_loanamount == 10000))
    loansizematrix <- cbind(loansize1, loansize2, loansize3, loansize4,
                        loansize5, loansize6)

  # Combine all the control covariates in one large matrix
    X <- as.matrix(cbind(X, loansizematrix, characteristicsmatrix))

# Initialize parameters
  numtrees <- 2000
  index <- c(1:5)
  dep.var <- 50 # 50 = monhtly profit, 51 = log of monthly HH income, 52 = capital
  lambdas <- c(0, 0.1, 0.3, 0.5, 0.7, 1, 1.5)
  boolean.lambdas <- FALSE
  boolean.plot <- FALSE
  version <- 1 # 1 = only current characteristics in X-matrix, 2 = all characteristics in X-matrix
  filename.plot.GRF.CATE <- "GRF CATE .pdf"
  filename.plot.CR.GRF.CATE <- "CR.GRF CATE .pdf"
  filename.plot.LLCF.CATE <- "LLCF CATE .pdf"
  
# Estimation procedure
run_method = function(numtrees, index, lambdas, boolean.plot, boolean.lambdas, version) {
  basic.results = sapply(index, function(i) {
    Y <- Grace_Period_Data[,(dep.var)]
    Y <- as.vector(Y)
    
    # Appoint characteristic for Table 5 (Field et al., 2013)
      characteristic <- Grace_Period_Data[,(74+i)]
      
    # Appoint final X-matrix
      if (version == 1) {
        current.X <- as.matrix(cbind(X, characteristic)
      } else {
        current.X <- as.matrix(cbind(X, X[,75:79])
      }
      
    # Determine missing values
      missingvalues <- as.integer(is.na(Y)) + as.integer(is.na(characteristic))
      missingvalues[missingvalues == 2] <- 1
  
    # Remove the observations for which Y and/or the characteristic for Table 5 has an NA value
      current.X <- X[!missingvalues,]
      current.W <- W[!missingvalues]
      current.loangroups <- loangroups[!missingvalues]
      current.characteristic <- characteristic[!missingvalues]
      current.Y <- Y[!missingvalues]
  
    ###########################
    ########### GRF ###########
    ###########################
    
      # Grow preliminary forests for (W, X) and (Y, X) separately
        forest.W <- regression_forest(current.X, current.W, num.trees = numtrees, honesty = TRUE, tune.parameters = "all")
        W.hat <- predict(forest.W)$predictions
        forest.Y <- regression_forest(current.X, current.Y, num.trees = numtrees, honesty = TRUE, tune.parameters = "all")
        Y.hat <- predict(forest.Y)$predictions
        
      # Compute the variable importance
        GRF.varimp <- variable_importance(forest.Y) 
        GRF.mostimportant <- colnames(current.X)[order(GRF.varimp)[1:4]] # 4 most important variables for splitting
        GRF.mostimportant <- c(GRF.mostimportant, colnames(characteristic))
        
      # Select variables to include using preliminary GRF
        prelim.GRF <- causal_forest(current.X, current.Y, current.W, Y.hat = Y.hat, W.hat = W.hat, num.trees = numtrees, honesty = TRUE)
        prelim.GRF.varimp <- variable_importance(prelim.GRF)
        selected.vars <- which(prelim.GRF.varimp / mean(prelim.GRF.varimp) > 0.2)
  
      # Implement GRF
        GRF <- causal_forest(current.X[,selected.vars], current.Y, current.W, Y.hat = Y.hat, W.hat = W.hat, num.trees = numtrees, 
                             honesty = TRUE, tune.parameters = "all")
        GRF.pred <- predict(GRF, estimate.variance = TRUE)
        GRF.CATE <- GRF.pred$predictions
        GRF.CATE.SE <- sqrt(GRF.pred$variance.estimates)
  
      # Find lower and upper bounds for 95% confidence intervals
        lower.GRF <- GRF.CATE - qnorm(0.975)*GRF.CATE.SE
        upper.GRF <- GRF.CATE + qnorm(0.975)*GRF.CATE.SE
    
      # Graph the predicted GRF heterogeneous treatment effect estimates
        if (boolean.plot == TRUE) {
          hist(GRF.CATE)
        }
    
      # Compute ATE with corresponding 95% confidence intervals
        GRF.ATE <- average_treatment_effect(GRF, target.sample = "all")
    
      # See if the GRF succeeded in capturing heterogeneity by plotting the TOC and calculating the 95% confidence interval for the AUTOC
        GRF.rate <- rank_average_treatment_effect(GRF, GRF.CATE, target = "AUTOC")
        if (boolean.plot == TRUE) {
          plot(GRF.rate)
        }

      # Assessing GRF fit and heterogeneity using the Best Linear Predictor Approach [BLP]
        GRF.BLP <- test_calibration(GRF)
        mean.forest.pred.GRF <- c(GRF.BLP[1,1], GRF.BLP[1,2], (GRF.BLP[1,4] < 0.10))
        diff.forest.pred.GRF <- c(GRF.BLP[2,1], GRF.BLP[2,2], (GRF.BLP[2,4] < 0.10))
    
      # Test of heterogeneity using Differential ATE
        GRF.ATE.charact <- average_treatment_effect(GRF, target.sample = "all", subset = (characteristic == 1))
        GRF.ATE.not.charact <- average_treatment_effect(GRF, target.sample = "all", subset = !(characteristic == 1))
        # DiffATE.GRF.mean <- GRF.ATE.charact[1] - GRF.ATE.not.charact[1]
        # DiffATE.GRF.SE <- sqrt(GRF.ATE.charact[2]^2 + GRF.ATE.not.charact[2]^2)
        # lower.DiffATE.GRF <- (DiffATE.GRF.mean - (qnorm(0.975) * DiffATE.GRF.SE))
        # upper.DiffATE.GRF <- (DiffATE.GRF.mean + (qnorm(0.975) * DiffATE.GRF.SE))
        DiffATE.GRF.test <- t.test(GRF.ATE.charact, GRF.ATE.not.charact, alternative = "two.sided", var.equal = FALSE)
        
      # Plot the estimated CATE against the covariates with the highest variable importance, and the characteristic vector
        if (boolean.plot == TRUE) {
          for (k in 1:length(GRF.mostimportant)) {
            # Set all variables at their median values
              X.median <- apply(current.X, 2, median)
              
            # Create ordered vector of important variable
              important.var.test = seq(min(current.X$(GRF.mostimportant[k])), max(current.X$(GRF.mostimportant[k])))
              
            # Create test set
              X.test <- matrix(rep(X.median, length(important.var.test)), length(important.var.test), byrow = TRUE)
              X.test[,(GRF.mostimportant[k])] = important.var.test
              
            # Predict new CATE estimates
              GRF.pred.test <- predict(GRF, X.test, estimate.variance = TRUE)
              GRF.CATE.test <- GRF.pred.test$predictions
              GRF.CATE.SE.test <- sqrt(GRF.pred.test$variance.estimates)
              lower.GRF.test <- GRF.CATE.test - qnorm(0.975)*GRF.CATE.SE.test
              upper.GRF.test <- GRF.CATE.test + qnorm(0.975)*GRF.CATE.SE.test
            
            # Make plot and save
              pdf(fun_insert(x = filename.plot.GRF.CATE, pos = (nchar(filename.plot.GRF.CATE) - 4), insert = (GRF.mostimportant[k])))
              plot(X.test[,(GRF.mostimportant[k])], GRF.CATE.test, type = "l", ylim = range(min(lower.GRF.test), max(upper.GRF.test)), xlab = GRF.mostimportant[k], ylab = "CATE")
              lines(X.test[,(GRF.mostimportant[k])], upper.GRF.test, col = 1, lty = 2)
              lines(X.test[,(GRF.mostimportant[k])], lower.GRF.test, col = 1, lty = 2)
              grid()
              dev.off()
          }
         }
        
    ############################
    #### Cluster-Robust GRF ####
    ############################
      
      # Select variables to include using preliminary Cluster-Robust GRF
        prelim.CR.GRF <- causal_forest(current.X, current.Y, current.W, Y.hat = Y.hat, W.hat = W.hat, honesty = TRUE, clusters = current.loangroups, num.trees = numtrees)
        prelim.CR.GRF.varimp <- variable_importance(prelim.CR.GRF)
        selected.vars <- which(prelim.CR.GRF.varimp / mean(prelim.CR.GRF.varimp) > 0.2)
  
      # Compute the variable importance
        CR.GRF.varimp <- variable_importance(forest.Y) 
        CR.GRF.mostimportant <- colnames(current.X)[order(CR.GRF.varimp)[1:4]] # 4 most important variables for splitting
        CR.GRF.mostimportant <- c(CR.GRF.mostimportant, colnames(characteristic))
        
      # Implement Cluster-Robust GRF
        CR.GRF <- causal_forest(current.X[,selected.vars], current.Y, current.W, Y.hat = Y.hat, W.hat = W.hat, clusters = current.loangroups, honesty = TRUE, num.trees = numtrees, 
                                tune.parameters = "all")
        CR.GRF.pred <- predict(CR.GRF, estimate.variance = TRUE)
        CR.GRF.CATE <- CR.GRF.pred$predictions
        CR.GRF.CATE.SE <- sqrt(CR.GRF.pred$variance.estimates)
    
      # Find lower and upper bounds for 95% confidence intervals
        lower.CR.GRF <- CR.GRF.CATE - qnorm(0.975)*CR.GRF.CATE.SE
        upper.CR.GRF <- CR.GRF.CATE + qnorm(0.975)*CR.GRF.CATE.SE
              
      # Graph the predicted Cluster-Robust GRF heterogeneous treatment effect estimates
        if (boolean.plot == TRUE) {
          hist(CR.GRF.CATE)
        }
    
      # Compute ATE with corresponding 95% confidence intervals
        CR.GRF.ATE <- average_treatment_effect(CR.GRF, target.sample = "all")
    
      # See if the Cluster-Robust GRF succeeded in capturing heterogeneity by plotting the TOC and calculating the 95% confidence interval for the AUTOC
        CR.GRF.rate <- rank_average_treatment_effect(CR.GRF, CR.GRF.CATE, target = "AUTOC")
        if (boolean.plot == TRUE) {
          plot(CR.GRF.rate)
        }
  
      # Assessing Cluster-Robust GRF fit using the Best Linear Predictor Approach [BLP]
        CR.GRF.BLP <- test_calibration(CR.GRF)
        mean.forest.pred.CR.GRF <- c(CR.GRF.BLP[1,1], CR.GRF.BLP[1,2], (CR.GRF.BLP[1,4] < 0.10))
        diff.forest.pred.CR.GRF <- c(CR.GRF.BLP[2,1], CR.GRF.BLP[2,2], (CR.GRF.BLP[2,4] < 0.10))
    
      # Test of heterogeneity using Differential ATE
        CR.GRF.ATE.charact <- average_treatment_effect(CR.GRF, target.sample = "all", subset = (characteristic == 1))
        CR.GRF.ATE.not.charact <- average_treatment_effect(CR.GRF, target.sample = "all", subset = !(characteristic == 1))
        # DiffATE.CR.GRF.mean <- CR.GRF.ATE.charact[1] - CR.GRF.ATE.not.charact[1]
        # DiffATE.GRF.SE <- sqrt(GRF.ATE.charact[2]^2 + GRF.ATE.not.charact[2]^2)
        # lower.DiffATE.GRF <- (DiffATE.GRF.mean - (qnorm(0.975) * DiffATE.GRF.SE))
        # upper.DiffATE.GRF <- (DiffATE.GRF.mean + (qnorm(0.975) * DiffATE.GRF.SE))
        DiffATE.CR.GRF.test <- t.test(CR.GRF.ATE.charact, CR.GRF.ATE.not.charact, alternative = "two.sided", var.equal = FALSE)
  
      # Plot the estimated CATE against the covariates with the highest variable importance, and the characteristic vector
        if (boolean.plot == TRUE) {
          for (k in 1:length(CR.GRF.mostimportant)) {
            # Set all variables at their median values
              X.median <- apply(current.X, 2, median)
              
            # Create ordered vector of important variable
              important.var.test = seq(min(current.X$(CR.GRF.mostimportant[k])), max(current.X$(CR.GRF.mostimportant[k])))
              
            # Create test set
              X.test <- matrix(rep(X.median, length(important.var.test)), length(important.var.test), byrow = TRUE)
              X.test[,(CR.GRF.mostimportant[k])] = important.var.test
              
            # Predict new CATE estimates
              CR.GRF.pred.test <- predict(CR.GRF, X.test, estimate.variance = TRUE)
              CR.GRF.CATE.test <- CR.GRF.pred.test$predictions
              CR.GRF.CATE.SE.test <- sqrt(CR.GRF.pred.test$variance.estimates)
              lower.CR.GRF.test <- CR.GRF.CATE.test - qnorm(0.975)*CR.GRF.CATE.SE.test
              upper.CR.GRF.test <- CR.GRF.CATE.test + qnorm(0.975)*CR.GRF.CATE.SE.test
            
            # Make plot and save
              pdf(fun_insert(x = filename.plot.CR.GRF.CATE, pos = (nchar(filename.plot.CR.GRF.CATE) - 4), insert = (CR.GRF.mostimportant[k])))
              plot(X.test[,(CR.GRF.mostimportant[k])], CR.GRF.CATE.test, type = "l", ylim = range(min(lower.CR.GRF.test), max(upper.CR.GRF.test)), xlab = CR.GRF.mostimportant[k], ylab = "CATE")
              lines(X.test[,(CR.GRF.mostimportant[k])], upper.CR.GRF.test, col = 1, lty = 2)
              lines(X.test[,(CR.GRF.mostimportant[k])], lower.CR.GRF.test, col = 1, lty = 2)
              grid()
              dev.off()
          }
         }
         
    ############################
    ########### LLCF ###########
    ############################
    
      # Grow preliminary forests for (W, X) and (Y, X) separately
        forest.W <- ll_regression_forest(current.X, current.W, honesty = TRUE, enable.ll.split = TRUE, ll.split.weight.penalty = TRUE, 
                                         num.trees = numtrees)
        W.hat <- predict(forest.W)$predictions
        forest.Y <- ll_regression_forest(current.X, current.Y, honesty = TRUE, enable.ll.split = TRUE, ll.split.weight.penalty = TRUE, 
                                         num.trees = numtrees)
        Y.hat <- predict(forest.Y)$predictions
    
      # Compute the variable importance
        LLCF.varimp <- variable_importance(forest.Y) 
        LLCF.mostimportant <- colnames(current.X)[order(LLCF.varimp)[1:4]] # 4 most important variables for splitting
        LLCF.mostimportant <- c(LLCF.mostimportant, colnames(characteristic))
        
      # Select variables to include using Lasso feature selection
        lasso.mod <- cv.glmnet(current.X, current.Y, alpha = 1)
        selected <- which(coef(lasso.mod) != 0)
        if(length(selected) < 2) {
          selected <- 1:ncol(current.X)
        } else {
          selected <- selected[-1] - 1 # Remove intercept
        }
  
      # Implement LLCF
        LLCF <- causal_forest(current.X, current.Y, current.W, Y.hat = Y.hat, W.hat = W.hat, honesty = TRUE,  
                              num.trees = numtrees, tune.parameters = "all")
    
        if (boolean.lambdas == FALSE) {
          # Predict: tuning without grid search over lambdas
            LLCF.pred <- predict(LLCF, linear.correction.variables = selected, ll.weight.penalty = TRUE, estimate.variance = TRUE)
            LLCF.CATE <- LLCF.pred$predictions
            LLCF.CATE.SE <- sqrt(LLCF.pred$variance.estimates)
        } else {
          # Predict: tuning done using set of lambdas
            LLCF.mse.old <- +Inf
            for (l in length(lambdas)) {
              LLCF.CATE.old <- predict(LLCF, linear.correction.variables = selected, ll.lambda = lambdas[l], ll.weight.penalty = TRUE, estimate.variance = TRUE)
              predictions <- LLCF.CATE.old$predictions
              LLCF.mse.new <- mean((predictions - mean(predictions))**2)
              if (LLCF.mse.new < LLCF.mse.old) {
                LLCF.mse.old <- LLCF.mse.new
                LLCF.CATE.SE <- sqrt(LLCF.CATE.old$variance.estimates))
                LLCF.CATE <- predictions
              }
            }
        }
        
      # Find lower and upper bounds for 95% confidence intervals
        lower.LLCF <- LLCF.CATE - qnorm(0.975)*LLCF.CATE.SE
        upper.LLCF <- LLCF.CATE + qnorm(0.975)*LLCF.CATE.SE
      
      # Graph the predicted Cluster-Robust GRF heterogeneous treatment effect estimates
        if (boolean.plot == TRUE) {
          hist(LLCF.CATE)
        }
    
      # Compute ATE with corresponding 95% confidence intervals
        LLCF.ATE <- average_treatment_effect(LLCF, target.sample = "all")
    
      # See if the Cluster-Robust GRF succeeded in capturing heterogeneity by plotting the TOC and calculating the 95% confidence interval for the AUTOC
        LLCF.rate <- rank_average_treatment_effect(LLCF, LLCF.CATE, target = "AUTOC")
        if (boolean.plot == TRUE) {
          plot(LLCF.rate)
        }
  
      # Assessing Cluster-Robust GRF fit using the Best Linear Predictor Approach [BLP]
        LLCF.BLP <- test_calibration(LLCF)
        mean.forest.pred.LLCF <- c(LLCF.BLP[1,1], LLCF.BLP[1,2], (LLCF.BLP[1,4] < 0.10))
        diff.forest.pred.LLCF <- c(LLCF.BLP[2,1], LLCF.BLP[2,2], (LLCF.BLP[2,4] < 0.10))
        
      # Test of heterogeneity using Differential ATE
        LLCF.ATE.charact <- average_treatment_effect(LLCF, target.sample = "all", subset = (characteristic == 1))
        LLCF.ATE.not.charact <- average_treatment_effect(LLCF, target.sample = "all", subset = !(characteristic == 1))
        # DiffATE.LLCF.mean <- LLCF.ATE.charact[1] - LLCF.ATE.not.charact[1]
        # DiffATE.LLCF.SE <- sqrt(LLCF.ATE.charact[2]^2 + LLCF.ATE.not.charact[2]^2)
        # lower.DiffATE.LLCF <- (DiffATE.LLCF.mean - (qnorm(0.975) * DiffATE.LLCF.SE))
        # upper.DiffATE.LLCF <- (DiffATE.LLCF.mean + (qnorm(0.975) * DiffATE.LLCF.SE))
        DiffATE.LLCF.test <- t.test(LLCF.ATE.charact, LLCF.ATE.not.charact, alternative = "two.sided", var.equal = FALSE)

      # Plot the estimated CATE against the covariates with the highest variable importance, and the characteristic vector
        if (boolean.plot == TRUE) {
          for (k in 1:length(LLCF.mostimportant)) {
            # Set all variables at their median values
              X.median <- apply(current.X, 2, median)
              
            # Create ordered vector of important variable
              important.var.test = seq(min(current.X$(LLCF.mostimportant[k])), max(current.X$(LLCF.mostimportant[k])))
              
            # Create test set
              X.test <- matrix(rep(X.median, length(important.var.test)), length(important.var.test), byrow = TRUE)
              X.test[,(LLCF.mostimportant[k])] = important.var.test
              
            # Predict new CATE estimates
              LLCF.pred.test <- predict(LLCF, X.test, estimate.variance = TRUE)
              LLCF.CATE.test <- LLCF.pred.test$predictions
              LLCF.CATE.SE.test <- sqrt(LLCF.pred.test$variance.estimates)
              lower.LLCF.test <- LLCF.CATE.test - qnorm(0.975)*LLCF.CATE.SE.test
              upper.LLCF.test <- LLCF.CATE.test + qnorm(0.975)*LLCF.CATE.SE.test
            
            # Make plot and save
              pdf(fun_insert(x = filename.plot.LLCF.CATE, pos = (nchar(filename.plot.LLCF.CATE) - 4), insert = (LLCF.mostimportant[k])))
              plot(X.test[,(LLCF.mostimportant[k])], LLCF.CATE.test, type = "l", ylim = range(min(lower.LLCF.test), max(upper.LLCF.test)), xlab = LLCF.mostimportant[k], ylab = "CATE")
              lines(X.test[,(LLCF.mostimportant[k])], upper.LLCF.test, col = 1, lty = 2)
              lines(X.test[,(LLCF.mostimportant[k])], lower.LLCF.test, col = 1, lty = 2)
              grid()
              dev.off()
          }
         }
         
        results_BLP <- data.frame(t(c(mean.forest.pred.GRF, diff.forest.pred.GRF, 
                         mean.forest.pred.CR.GRF, diff.forest.pred.CR.GRF, 
                         mean.forest.pred.LLCF, diff.forest.pred.LLCF)))
    
        results_DiffATE <- data.frame(t(c(paste(round(GRF.ATE.charact[1], 3), "(", round(GRF.ATE.charact[2], 3), ")"),
                                          paste(round(GRF.ATE.not.charact[1], 3), "(", round(GRF.ATE.not.charact[2], 3), ")"),
                                          paste(round(DiffATE.GRF.test$p.value, 3)),
                                          paste(round(CR.GRF.ATE.charact[1], 3), "(", round(CR.GRF.ATE.charact[2], 3), ")"),
                                          paste(round(CR.GRF.ATE.not.charact[1], 3), "(", round(CR.GRF.ATE.not.charact[2], 3), ")"),
                                          paste(round(DiffATE.CR.GRF.test$p.value, 3)),
                                          paste(round(LLCF.ATE.charact[1], 3), "(", round(LLCF.ATE.charact[2], 3), ")"),
                                          paste(round(LLCF.ATE.not.charact[1], 3), "(", round(LLCF.ATE.not.charact[2], 3), ")"),
                                          paste(round(DiffATE.LLCF.test$p.value, 3)),
                                          (845 - sum(missingvalues)))))   
    
        data.frame(cbind(results_BLP, results_DiffATE))
    })
    results_BLP <- basic.results[,1:6]        
    colnames(results_BLP) <- c("BLP[1] GRF", "BLP[2] GRF", "BLP[1] CR.GRF", "BLP[2] CR.GRF", "BLP[1] LLCF", "BLP[2] LLCF")
    rownames(results_BLP) <- c("savings", "risk loving", "wage earner", "household member chronically ill", "impatient")   
    
    results_DiffATE <- basic.results[,7:17]                                    
    colnames(results_DiffATE) <- c("GRF CATE subgroup", "GRF CATE rest", "GRF p-value difference", 
                                   "CR.GRF CATE subgroup", "CR.GRF CATE rest", "CR.GRF p-value difference",
                                   "LLCF CATE subgroup", "LLCF CATE rest", "LLCF p-value difference", "Number of observations")
    rownames(results_DiffATE) <- c("savings", "risk loving", "wage earner", "household member chronically ill", "impatient")
    
    results = list("results_BLP" = results_BLP, 
                         "results_DiffATE" = results_DiffATE)                              
    return(results)
}

fun_insert <- function(x, pos, insert) {
  gsub(paste0("^(.{", pos, "})(.*)$"),
       paste0("\\1", insert, "\\2"),
       x)
}

results = run_method(numtrees, index, lambdas, boolean.plot, boolean.lambdas, version)
results_table5 <- list('Sheet1' = results[["results_BLP"]], 'Sheet2' = results[["results_DiffATE"]])
write.xlsx(results_table5, file = "Table 5 (Field et al., 2013).xlsx")
